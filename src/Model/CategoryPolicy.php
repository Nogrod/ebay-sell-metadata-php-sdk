<?php

/**
 * CategoryPolicy
 *
 * PHP version 8.1
 *
 * @package  eBay\Sell\Metadata
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Metadata API
 *
 * The Metadata API has operations that retrieve configuration details pertaining to the different eBay marketplaces. In addition to marketplace information, the API also has operations that get information that helps sellers list items on eBay.
 *
 * The version of the OpenAPI document: v1.11.0
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace eBay\Sell\Metadata\Model;

use ArrayAccess;
use JsonSerializable;
use InvalidArgumentException;
use ReturnTypeWillChange;
use eBay\Sell\Metadata\ObjectSerializer;

/**
 * CategoryPolicy Class Doc Comment
 *
 * @description This type contains applicable policy metadata for the leaf categories returned for the marketplace.
 * @package  eBay\Sell\Metadata
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements ArrayAccess<string, mixed>
 */
class CategoryPolicy implements ModelInterface, ArrayAccess, JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static string $openAPIModelName = 'CategoryPolicy';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var array<string, string>
      */
    protected static array $openAPITypes = [
        'auto_pay_enabled' => 'bool',
        'b2b_vat_enabled' => 'bool',
        'category_id' => 'string',
        'category_tree_id' => 'string',
        'ean_support' => 'string',
        'expired' => 'bool',
        'intangible_enabled' => 'bool',
        'isbn_support' => 'string',
        'lsd' => 'bool',
        'minimum_reserve_price' => 'float',
        'orpa' => 'bool',
        'orra' => 'bool',
        'payment_methods' => 'string[]',
        'reduce_reserve_allowed' => 'bool',
        'upc_support' => 'string',
        'virtual' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var array<string, string|null>
      */
    protected static array $openAPIFormats = [
        'auto_pay_enabled' => null,
        'b2b_vat_enabled' => null,
        'category_id' => null,
        'category_tree_id' => null,
        'ean_support' => null,
        'expired' => null,
        'intangible_enabled' => null,
        'isbn_support' => null,
        'lsd' => null,
        'minimum_reserve_price' => null,
        'orpa' => null,
        'orra' => null,
        'payment_methods' => null,
        'reduce_reserve_allowed' => null,
        'upc_support' => null,
        'virtual' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var array<string, bool>
      */
    protected static array $openAPINullables = [
        'auto_pay_enabled' => false,
        'b2b_vat_enabled' => false,
        'category_id' => false,
        'category_tree_id' => false,
        'ean_support' => false,
        'expired' => false,
        'intangible_enabled' => false,
        'isbn_support' => false,
        'lsd' => false,
        'minimum_reserve_price' => false,
        'orpa' => false,
        'orra' => false,
        'payment_methods' => false,
        'reduce_reserve_allowed' => false,
        'upc_support' => false,
        'virtual' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var array<string, bool>
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPITypes(): array
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPIFormats(): array
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array<string, bool>
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return array<string, bool>
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param array<string, bool> $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var array<string, string>
     */
    protected static array $attributeMap = [
        'auto_pay_enabled' => 'autoPayEnabled',
        'b2b_vat_enabled' => 'b2bVatEnabled',
        'category_id' => 'categoryId',
        'category_tree_id' => 'categoryTreeId',
        'ean_support' => 'eanSupport',
        'expired' => 'expired',
        'intangible_enabled' => 'intangibleEnabled',
        'isbn_support' => 'isbnSupport',
        'lsd' => 'lsd',
        'minimum_reserve_price' => 'minimumReservePrice',
        'orpa' => 'orpa',
        'orra' => 'orra',
        'payment_methods' => 'paymentMethods',
        'reduce_reserve_allowed' => 'reduceReserveAllowed',
        'upc_support' => 'upcSupport',
        'virtual' => 'virtual'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var array<string, string>
     */
    protected static array $setters = [
        'auto_pay_enabled' => 'setAutoPayEnabled',
        'b2b_vat_enabled' => 'setB2bVatEnabled',
        'category_id' => 'setCategoryId',
        'category_tree_id' => 'setCategoryTreeId',
        'ean_support' => 'setEanSupport',
        'expired' => 'setExpired',
        'intangible_enabled' => 'setIntangibleEnabled',
        'isbn_support' => 'setIsbnSupport',
        'lsd' => 'setLsd',
        'minimum_reserve_price' => 'setMinimumReservePrice',
        'orpa' => 'setOrpa',
        'orra' => 'setOrra',
        'payment_methods' => 'setPaymentMethods',
        'reduce_reserve_allowed' => 'setReduceReserveAllowed',
        'upc_support' => 'setUpcSupport',
        'virtual' => 'setVirtual'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var array<string, string>
     */
    protected static array $getters = [
        'auto_pay_enabled' => 'getAutoPayEnabled',
        'b2b_vat_enabled' => 'getB2bVatEnabled',
        'category_id' => 'getCategoryId',
        'category_tree_id' => 'getCategoryTreeId',
        'ean_support' => 'getEanSupport',
        'expired' => 'getExpired',
        'intangible_enabled' => 'getIntangibleEnabled',
        'isbn_support' => 'getIsbnSupport',
        'lsd' => 'getLsd',
        'minimum_reserve_price' => 'getMinimumReservePrice',
        'orpa' => 'getOrpa',
        'orra' => 'getOrra',
        'payment_methods' => 'getPaymentMethods',
        'reduce_reserve_allowed' => 'getReduceReserveAllowed',
        'upc_support' => 'getUpcSupport',
        'virtual' => 'getVirtual'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array<string, string>
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array<string, string>
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array<string, string>
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName(): string
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var array
     */
    protected array $container = [];

    /**
     * Constructor
     *
     * @param array $data Associated array of property values initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('auto_pay_enabled', $data ?? [], null);
        $this->setIfExists('b2b_vat_enabled', $data ?? [], null);
        $this->setIfExists('category_id', $data ?? [], null);
        $this->setIfExists('category_tree_id', $data ?? [], null);
        $this->setIfExists('ean_support', $data ?? [], null);
        $this->setIfExists('expired', $data ?? [], null);
        $this->setIfExists('intangible_enabled', $data ?? [], null);
        $this->setIfExists('isbn_support', $data ?? [], null);
        $this->setIfExists('lsd', $data ?? [], null);
        $this->setIfExists('minimum_reserve_price', $data ?? [], null);
        $this->setIfExists('orpa', $data ?? [], null);
        $this->setIfExists('orra', $data ?? [], null);
        $this->setIfExists('payment_methods', $data ?? [], null);
        $this->setIfExists('reduce_reserve_allowed', $data ?? [], null);
        $this->setIfExists('upc_support', $data ?? [], null);
        $this->setIfExists('virtual', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, mixed $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return string[] invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets auto_pay_enabled
     *
     * @return bool|null
     */
    public function getAutoPayEnabled(): ?bool
    {
        return $this->container['auto_pay_enabled'];
    }

    /**
     * Sets auto_pay_enabled
     *
     * @param bool|null $auto_pay_enabled If this field is returned as <code>true</code>, the corresponding category supports immediate payment for listings. The immediate payment feature is applicable to fixed-price listings, to auction listings with the 'Buy It Now' option enabled, and for a motor vehicle listing that requires an initial deposit. If the immediate payment feature is enabled for a listing, the buyer must pay immediately after clicking the 'Buy it Now' button. <p>This field is only returned when <code>true</code> (not returned when false).</p>
     *
     * @return $this
     */
    public function setAutoPayEnabled(?bool $auto_pay_enabled): static
    {
        if (is_null($auto_pay_enabled)) {
            throw new InvalidArgumentException('non-nullable auto_pay_enabled cannot be null');
        }
        $this->container['auto_pay_enabled'] = $auto_pay_enabled;

        return $this;
    }

    /**
     * Gets b2b_vat_enabled
     *
     * @return bool|null
     */
    public function getB2bVatEnabled(): ?bool
    {
        return $this->container['b2b_vat_enabled'];
    }

    /**
     * Sets b2b_vat_enabled
     *
     * @param bool|null $b2b_vat_enabled If this field is returned as <code>true</code>, the corresponding category supports business-to-business (B2B) VAT listings. If this field is not present, the category does not have B2B VAT listings. This feature is applicable to the eBay Germany (DE), Austria (AT), and Switzerland (CH) sites only.<p>This field is only returned when <code>true</code> (not returned when false).</p>
     *
     * @return $this
     */
    public function setB2bVatEnabled(?bool $b2b_vat_enabled): static
    {
        if (is_null($b2b_vat_enabled)) {
            throw new InvalidArgumentException('non-nullable b2b_vat_enabled cannot be null');
        }
        $this->container['b2b_vat_enabled'] = $b2b_vat_enabled;

        return $this;
    }

    /**
     * Gets category_id
     *
     * @return string|null
     */
    public function getCategoryId(): ?string
    {
        return $this->container['category_id'];
    }

    /**
     * Sets category_id
     *
     * @param string|null $category_id The unique identifier of the eBay leaf category for which metadata is being returned.
     *
     * @return $this
     */
    public function setCategoryId(?string $category_id): static
    {
        if (is_null($category_id)) {
            throw new InvalidArgumentException('non-nullable category_id cannot be null');
        }
        $this->container['category_id'] = $category_id;

        return $this;
    }

    /**
     * Gets category_tree_id
     *
     * @return string|null
     */
    public function getCategoryTreeId(): ?string
    {
        return $this->container['category_tree_id'];
    }

    /**
     * Sets category_tree_id
     *
     * @param string|null $category_tree_id The unique identifier of the category tree.
     *
     * @return $this
     */
    public function setCategoryTreeId(?string $category_tree_id): static
    {
        if (is_null($category_tree_id)) {
            throw new InvalidArgumentException('non-nullable category_tree_id cannot be null');
        }
        $this->container['category_tree_id'] = $category_tree_id;

        return $this;
    }

    /**
     * Gets ean_support
     *
     * @return string|null
     */
    public function getEanSupport(): ?string
    {
        return $this->container['ean_support'];
    }

    /**
     * Sets ean_support
     *
     * @param string|null $ean_support This enumerated value indicates whether or not European Article Numbers (EANs) are supported/required when listing products in the category. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/metadata/types/sel:ProductIdentiferEnabledEnum'>eBay API documentation</a>
     *
     * @return $this
     */
    public function setEanSupport(?string $ean_support): static
    {
        if (is_null($ean_support)) {
            throw new InvalidArgumentException('non-nullable ean_support cannot be null');
        }
        $this->container['ean_support'] = $ean_support;

        return $this;
    }

    /**
     * Gets expired
     *
     * @return bool|null
     */
    public function getExpired(): ?bool
    {
        return $this->container['expired'];
    }

    /**
     * Sets expired
     *
     * @param bool|null $expired If this field is returned as <code>true</code>, the corresponding category is no longer a valid eBay category on the site, and items may not be listed in this category. You can use the <a href=\"/api-docs/sell/taxonomy/resources/category_tree/methods/getExpiredCategories\" target=\"_blank\">getExpiredCategories</a> method (of the <b>Taxonomy API</b>) to find the leaf category that replaced the expired category. <p>This field is only returned when <code>true</code> (not returned when false).</p>
     *
     * @return $this
     */
    public function setExpired(?bool $expired): static
    {
        if (is_null($expired)) {
            throw new InvalidArgumentException('non-nullable expired cannot be null');
        }
        $this->container['expired'] = $expired;

        return $this;
    }

    /**
     * Gets intangible_enabled
     *
     * @return bool|null
     */
    public function getIntangibleEnabled(): ?bool
    {
        return $this->container['intangible_enabled'];
    }

    /**
     * Sets intangible_enabled
     *
     * @param bool|null $intangible_enabled If this field is returned as <code>true</code>, the category supports the listing of intangible goods or services.
     *
     * @return $this
     */
    public function setIntangibleEnabled(?bool $intangible_enabled): static
    {
        if (is_null($intangible_enabled)) {
            throw new InvalidArgumentException('non-nullable intangible_enabled cannot be null');
        }
        $this->container['intangible_enabled'] = $intangible_enabled;

        return $this;
    }

    /**
     * Gets isbn_support
     *
     * @return string|null
     */
    public function getIsbnSupport(): ?string
    {
        return $this->container['isbn_support'];
    }

    /**
     * Sets isbn_support
     *
     * @param string|null $isbn_support This enumerated value indicates whether or not International Standard Book Numbers (ISBNs) are supported/required when listing products in the specified category. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/metadata/types/sel:ProductIdentiferEnabledEnum'>eBay API documentation</a>
     *
     * @return $this
     */
    public function setIsbnSupport(?string $isbn_support): static
    {
        if (is_null($isbn_support)) {
            throw new InvalidArgumentException('non-nullable isbn_support cannot be null');
        }
        $this->container['isbn_support'] = $isbn_support;

        return $this;
    }

    /**
     * Gets lsd
     *
     * @return bool|null
     */
    public function getLsd(): ?bool
    {
        return $this->container['lsd'];
    }

    /**
     * Sets lsd
     *
     * @param bool|null $lsd If this field (Lot Size Disabled) is returned as <code>true</code>, the corresponding category does not support lot listings. A lot listing is a listing that features multiple related items that must be purchased by one buyer in one transaction. <p>This field is only returned when <code>true</code> (not returned when false).</p>
     *
     * @return $this
     */
    public function setLsd(?bool $lsd): static
    {
        if (is_null($lsd)) {
            throw new InvalidArgumentException('non-nullable lsd cannot be null');
        }
        $this->container['lsd'] = $lsd;

        return $this;
    }

    /**
     * Gets minimum_reserve_price
     *
     * @return float|null
     */
    public function getMinimumReservePrice(): ?float
    {
        return $this->container['minimum_reserve_price'];
    }

    /**
     * Sets minimum_reserve_price
     *
     * @param float|null $minimum_reserve_price Indicates the Minimum Reserve Price for an auction listing in this category. If there is no Minimum Reserve Price, a value of <code>0.0</code> is returned in this field.
     *
     * @return $this
     */
    public function setMinimumReservePrice(?float $minimum_reserve_price): static
    {
        if (is_null($minimum_reserve_price)) {
            throw new InvalidArgumentException('non-nullable minimum_reserve_price cannot be null');
        }
        $this->container['minimum_reserve_price'] = $minimum_reserve_price;

        return $this;
    }

    /**
     * Gets orpa
     *
     * @return bool|null
     */
    public function getOrpa(): ?bool
    {
        return $this->container['orpa'];
    }

    /**
     * Sets orpa
     *
     * @param bool|null $orpa If this field (Override Reserve Price Allowed) is returned as <code>true</code>, all leaf categories on the site allow the seller to completely remove the reserve price for an active auction listing. For information on removing or reducing reserve prices, see <a href=\"https://www.ebay.com/help/selling/listings/selling-auctions/reserve-prices?id=4143\"  target=\"_blank\">Setting a reserve price</a>.
     *
     * @return $this
     */
    public function setOrpa(?bool $orpa): static
    {
        if (is_null($orpa)) {
            throw new InvalidArgumentException('non-nullable orpa cannot be null');
        }
        $this->container['orpa'] = $orpa;

        return $this;
    }

    /**
     * Gets orra
     *
     * @return bool|null
     */
    public function getOrra(): ?bool
    {
        return $this->container['orra'];
    }

    /**
     * Sets orra
     *
     * @param bool|null $orra If this field (Override Reduce Reserve Allowed) is returned as <code>true</code>, the seller can reduce or remove a reserve price that had already been reduced for an active auction listing.
     *
     * @return $this
     */
    public function setOrra(?bool $orra): static
    {
        if (is_null($orra)) {
            throw new InvalidArgumentException('non-nullable orra cannot be null');
        }
        $this->container['orra'] = $orra;

        return $this;
    }

    /**
     * Gets payment_methods
     *
     * @return string[]|null
     */
    public function getPaymentMethods(): ?array
    {
        return $this->container['payment_methods'];
    }

    /**
     * Sets payment_methods
     *
     * @param string[]|null $payment_methods An array that indicates the acceptable offline payment methods that can be used when listing an item for sale in the corresponding category.
     *
     * @return $this
     */
    public function setPaymentMethods(?array $payment_methods): static
    {
        if (is_null($payment_methods)) {
            throw new InvalidArgumentException('non-nullable payment_methods cannot be null');
        }
        $this->container['payment_methods'] = $payment_methods;

        return $this;
    }

    /**
     * Gets reduce_reserve_allowed
     *
     * @return bool|null
     */
    public function getReduceReserveAllowed(): ?bool
    {
        return $this->container['reduce_reserve_allowed'];
    }

    /**
     * Sets reduce_reserve_allowed
     *
     * @param bool|null $reduce_reserve_allowed If this field (Reduce Reserve Allowed) is <code>true</code>, the corresponding leaf category allows the seller to reduce an item's reserve price. If false, this field is not returned in the response and the corresponding leaf category on the site do not normally allow sellers to reduce an item's reserve price.<p>This field is only returned when <code>true</code> (not returned when false).</p>
     *
     * @return $this
     */
    public function setReduceReserveAllowed(?bool $reduce_reserve_allowed): static
    {
        if (is_null($reduce_reserve_allowed)) {
            throw new InvalidArgumentException('non-nullable reduce_reserve_allowed cannot be null');
        }
        $this->container['reduce_reserve_allowed'] = $reduce_reserve_allowed;

        return $this;
    }

    /**
     * Gets upc_support
     *
     * @return string|null
     */
    public function getUpcSupport(): ?string
    {
        return $this->container['upc_support'];
    }

    /**
     * Sets upc_support
     *
     * @param string|null $upc_support This enumerated value indicates whether or not the category on the specified eBay site supports the use of Universal Product Codes (UPCs) to help create a listing. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/metadata/types/sel:ProductIdentiferEnabledEnum'>eBay API documentation</a>
     *
     * @return $this
     */
    public function setUpcSupport(?string $upc_support): static
    {
        if (is_null($upc_support)) {
            throw new InvalidArgumentException('non-nullable upc_support cannot be null');
        }
        $this->container['upc_support'] = $upc_support;

        return $this;
    }

    /**
     * Gets virtual
     *
     * @return bool|null
     */
    public function getVirtual(): ?bool
    {
        return $this->container['virtual'];
    }

    /**
     * Sets virtual
     *
     * @param bool|null $virtual If this field is returned as <code>true</code>, the corresponding category is an eBay virtual category, a category in which items may not be listed.<p>This field is only returned when <code>true</code> (not returned when false).</p>
     *
     * @return $this
     */
    public function setVirtual(?bool $virtual): static
    {
        if (is_null($virtual)) {
            throw new InvalidArgumentException('non-nullable virtual cannot be null');
        }
        $this->container['virtual'] = $virtual;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[ReturnTypeWillChange]
    public function offsetGet(mixed $offset): mixed
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize(): mixed
    {
        return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString(): string
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue(): string
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


